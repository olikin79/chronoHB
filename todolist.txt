EVOLUTIONS DEMANDEES POUR LES TRAILEURS DU RANDON :
- générer un pdf avec 6 qrcodes par page.
- faire en sorte qu'un coureur d'une catégorie puisse s'inscrire à n'importe quelle course, de distances différentes.
Ce ne serait plus la catégorie qui donnerait la course mais une propriété (à créer) du coureur.
Dans les paramètres, une checkbox permettrait de choisir "courses en fonction des catégories ou non".
Un champ Entry apparaîtrait en cas de choix "courses manuelles" qui engendrerait l'apparition d'un combobox dans ajout-modif de coureur lié à une propriété
Coureur.course, qui pourrait être importée via le tableur ou CSV.
Dans le menu "paramètres des courses", la partie gauche disparaîtrait, la partie droite prendrait alors en compte ce nouveau paramètre.

- Idéalement, les dossards coderaient 1A, 2A, 3A pour la première course, 1B, 2B, ... pour la 2ème course. 
Coureurs deviendrait un dictionnaire {A:[Coureur 1A, Coureur 2A,...],B:[coureur 1B, ...],...}
Même schéma pour ArriveeDossards, 

Utilisé : les fonctions d'accès créées transformeront le paramètre fourni en une chaine de caractères et testeront si le dernier
caractère est une lettre : si oui, c'est l'entrée du dictionnaire ; si non, ce sera la course A par défaut.
1. len(Coureurs)						pour 1, la propriété nombreDeCoureurs devra faire le travail.
2. Coureurs[doss-1]						pour 2, recuperer(doss) devra faire le travail
3. i = 0								pour 3 et 4, une fonction liste() devrait faire l'affaire.
    while i < len (Coureurs) :
        coureur = Coureurs[i]
4. for coureur in Coureurs
5. dossard = len(Coureurs)+1							pour 5. difficile de connaître le numéro de dossard sans connaitre la course à l'avance.
   Coureurs.append(Coureur(dossard, nom, prenom, ...))			du coup, cela serait réservé au seul cas des CoursesManuelles.
																ajouter(coureur) à créer : le coureur, une fois ajouté se voit affecter
   Coureurs[-1].setCourse(addCourse(course))					son numéro de dossard automatiquement par ajouter(coureur) elle-même 
																et elle retourne ce dossard. Cela peut servir ici pour la ligne qui suit.
																
6. doss = int(dossard)					à supprimer systématiquement.
7. del Coureurs[doss-1]					pour 7. créer effacer(doss) ou effacer(coureur) qui ferait le travail et retournerait un code de succès ou d'erreur.

8. coureurExists(Coureurs, nom, prenom) à remplacer par une méthode intégrée self.existe(coureur)


- limiter l'usage de ces dossards au seul cas : CoursesManuelles == True


##### penser à modifier le scritp cgi pour qu'il utilise le fichier CoureursA.txt , etc...




BUGS RESTANTS dans chronoHB :
PRIORITAIRES :
un paramètre comme le changement de type de dossard ne s'actualise qu'après un redémarrage de l'application. Bug confirmé à corriger.

(à confirmer) : on modifie le nom d'un groupement et on demande son affichage sur la TV en cochant la case
correspondant. Il me semble que cela provoque un bug... Redémarrer chronoHB résoudrait le bug.



NON PRIORITAIRES :
- FONCTIONNELS : si on remplit le tableau avec quelques temps puis on le vide, on constate le bug suivant :
si on supprime d'un coup plusieurs lignes, elles disparaissent effectivement de l'affichage.
si on ne supprime qu'une seule ligne, alors elle persiste dans l'affichage (mais pas dans la base, ce qui fait qu'un nouveau lancement du logiciel
ou un nouveau temps ajouté ensuite la font disparaître.

- Le status dispensé ou absent devrait être cumulable : élimination du combobox et utilisation de cases à cocher.
Attention à répercuter ces éventuels deux status dans les pdf générés et dans le tableur xls si tel est le cas.
La class Coureur() permet déjà le cumul, je pense...

- Selon la taille des noms des catégories, les cases à cocher pour l'affichage TV débordent de l'écran. Faire en sorte que cela soit adaptatif.
Créer un affichage qui dépend de la longueur totale à afficher avec retour à la ligne. Actuellement, on coupe en deux les combobox.

- changer les fichiers textes de db en une extension comme chb (pour chronoHB) afin d'ignorer dans GIT tous les fichiers chb... Plus pratique !



- ULTRA-PEU-PROBABLE (ignoré lors de l'implémentation de l'UNSS) :
	* si on est en présence d'une course UNSS, qu'il n'y a que des cadets G et des juniors F (ou l'inverse), le challenge Lycée ne sera pas créé.
Cela ne peut pas survenir vu qu'il y a toujours des cadets, cadettes, juniors et juniores sur une compétition UNSS.
S'il n'y a que des cadets et cadettes, tout fonctionne (idem si juniors et juniores).
Compliqué de gérer ce cas improbable en pratique, vu que le challenge lycée regroupe les catégories CA et JU, qui peuvent être filles ou
garçons et que son nom ne correspond pas aux catégories officielles des courses courues.

	* si on est en présence d'une course UNSS, qu'un coureur M10 (vétéran dernière catégorie) courre avec les jeunes de lycée, 
alors celui-ci pourra entrer dans n'importe quel challenge sans limitation. Cela vient du fait que M10 comporte 3 caractères contrairement à
toutes les catégories. Pas créé de cas particulier pour cette éventualité (qui ne peut pas survenir en pratique).


- ESTHETIQUE :
	* dans le pdf qui affiche les résultats d'un groupement, quand la colonne vitesse n'est pas assez large,
	( cas où il y a la vitesse et la VMA ),  les éléments ne sont pas centrés correctement.
	* la droiteFrame devrait être munie d'un scroll haut-bas afin de gérer le cas où les éléments affichés sont trop nombreux. 
	Non réussi avec la class dérivée de Frame présente en début de code de chronoHB.py
	* si un temps est entre minuit et 1H, lors de la fermeture de l'application, le temps affiché est incorrect.
	Aucun impact sur les temps calculés et les statistiques. 
	Impact sur l'affichage TV sur le chronomètre en temps réel affiché en haut ? A vérifier.
	Exemple : 00:44:20:34 devient, après fermeture puis ouverture de l'application 44:20:34.

	


A TESTER :




FONCTIONNALITES MANQUANTES dans chronoHB.py :
PRIORITAIRES :
- permettre d'afficher sur la TV les vidéos : dans la zone d'affichage, développer un combobox qui affichera
les noms des dossards concernés (théoriquement) par un enregistrement qu'il serait possible de cocher pour diffusion sur la TV.
Placer cette diffusion au tout début de la page web, avant les tableaux. Cela permettrait de palier toute demande 
de vérification et de laisser les coureurs concernés loin des installations.

	
MOYENNEMENT PRIORITAIRE :
- remplacer l'usage de xlswriter par openpyxl lors de l'export => possibilité d'éliminer cette dépendance.
- mise en page du tableau par catégories dans les statistiques : inutile de distinguer le sexe dans deux colonnes.
Cela a sa raison d'être pour les groupements ou pour les classes (qui sont dans Resultats, à maintenir) mais pas pour les catégories (également dans Résultats).
- accepter la pondération pour les challenges par classe.
- le défilement automatique de MonTableau ne s'effectue que par blocs de 2 lignes.
- trouver les différentes fonctions d'actualisation de l'interface GUI. Il semble y avoir 3 qui font sûrement doublon. A réfléchir.
Source d'incompréhension en cas de bizarreries d'affichage potentielles. Pas de bug constaté pour l'instant.
- prévoir une procédure en cas de plantage au démarrage lié à une base de données incorrecte.
try : except : dans le traitement des données afin d'éviter une interface plantée comme ci-après :
Traceback (most recent call last):
  File "C:\Users\olikin\Documents\GitHub\chronoHB\chronoHB.py", line 1866, in <module>
    timer=Clock(root, "tableau.maj")
  File "C:\Users\olikin\Documents\GitHub\chronoHB\chronoHB.py", line 1765, in __init__
    self.update_clock()
  File "C:\Users\olikin\Documents\GitHub\chronoHB\chronoHB.py", line 1776, in update_clock
    traitementLocal = traiterDonneesLocales()
  File "C:\Users\olikin\Documents\GitHub\chronoHB\FonctionsMetiers.py", line 1162, in traiterDonneesLocales
    codeErreur = decodeActionsRecupSmartphone(ligne, local=True)
  File "C:\Users\olikin\Documents\GitHub\chronoHB\FonctionsMetiers.py", line 1231, in decodeActionsRecupSmartphone
    retour = addArriveeDossard(dossard, dossardPrecedent)
  File "C:\Users\olikin\Documents\GitHub\chronoHB\FonctionsMetiers.py", line 2747, in addArriveeDossard
    coureur = Coureurs[doss-1]
IndexError: list index out of range

Devrait lancer recupererSauvegardeGUI() en cas de plantage afin de charger une base correcte.


A PLUS LONG TERME :
- faire en sorte que les numéros de la première colonne du tableauGUI soient systématiquement avec le bon nombre de chiffres
(interne à la class tableauGUI) si moins de 100 résultats : à deux chiffres. Si moins de mille résultats, à trois chiffres, etc...
Ainsi, quand on effectue un tri par colonne, actuellement, j'ai mis 3 chiffres tout le temps. Développement court qui devra se baser sur la méthode formateSurNChiffres() 
en déterminant le nombre total de lignes et on l'appliquant à posteriori à tout le tableau quand ce total dépassera 100, 1000, etc...
- dans ajout manuel de coureur, la classe devrait être une liste combobox avec les classes précédentes mais permettant de saisir une nouvelle classe.
- pouvoir choisir l'imprimante vers laquelle on imprime dans les paramètres.
- quand MonTableau contient plus de 10 colonnes, impossible d'éditer une cellule au delà de la 10ème : problème de base 16 à convertir en base 10 (ou l'inverse, car écrit de mémoire...)
(Inutile en l'état actuel des besoins)
- l'affichage.html pourrait être exporté à chaque actualisation vers un serveur ftp sur le web (identifiants+mdp+adresse à renseigner dans les paramètres).
Ainsi, n'importe quel autre ordintateur relié à internet, plus lointain (sans wifi), pourrait afficher les résultats.
Actuellement, il faut que le deuxième ordinateur soit sur le même réseau wifi pour afficher la page http://ip-serveur-chronoHB/Affichage.html .
- si la génération des dossards (ou des résultats ou du xlxs) échouent, c'est probablement lié à un fichier ouvert dans adobe reader ou excel. 
	Inviter l'utilisateur à fermer ces logiciels par un pop-up.
- possibilité de configurer les dossards générés : possibilité de trier les coureurs du listing par ordre alphabétique (et non par création=> dossard, comme actuellement)
d'imprimer les dossards par groupements, catégories, classes avec des cases à cocher dans un menu dédié...
- dans les paramètres, permettre de changer l'option : "statistiques en % ou en effectifs".
- Ajouter un mode sombre via l'interface (case à cocher) pour utiliser la css mode-sombre. 
- segmenter le code pour séparer les classes de données (AVANT DE DIFFUSER REELLEMENT LE LOGICIEL)
- Créer un système évitant des incohérences entre les smartphones et la base locale : 
un numéro de course unique qui empêcherait toute communication tant que les données n'ont pas été coordonnées ou celles du smartphone effacées.
A réfléchir...
